// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgcrypto]
}

enum PIECE_CATEGORY {
  KEYBOARD
  CHAMBER_INSTRUMENTAL
  ORCHESTRAL
  VOCAL
  OTHER
}

model Piece {
  id                String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title             String
  nickname          String?
  composer          Person         @relation(fields: [composerId], references: [id]) // A piece have a unique composer
  composerId        String
  yearOfComposition Int?
  creator           User?          @relation(fields: [creatorId], references: [id])
  creatorId         String?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  pieceVersions     PieceVersion[] // A piece can have many versions

  @@unique([composerId, title])
}

model PieceVersion {
  id        String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  piece     Piece          @relation(fields: [pieceId], references: [id]) // A piece version belongs to a single piece
  pieceId   String
  category  PIECE_CATEGORY
  movements Movement[] // A pieceVersion can have many movements
  sources   Source[] // A pieceVersion can have many sources
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
}

model Movement {
  id             String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  pieceVersion   PieceVersion @relation(fields: [pieceVersionId], references: [id]) // A movement belongs to a single piece
  pieceVersionId String
  rank           Int
  key            KEY
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  sections       Section[] // A movement can have many sections

  @@unique([pieceVersionId, rank])
}

model Section {
  id                              String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  movement                        Movement         @relation(fields: [movementId], references: [id])
  movementId                      String
  rank                            Int
  metreNumerator                  Int
  metreDenominator                Int
  isCommonTime                    Boolean          @default(false)
  isCutTime                       Boolean          @default(false)
  fastestStructuralNotesPerBar    Float
  fastestStaccatoNotesPerBar      Float?
  fastestRepeatedNotesPerBar      Float?
  fastestOrnamentalNotesPerBar    Float?
  isFastestStructuralNoteBelCanto Boolean          @default(false)
  tempoIndication                 TempoIndication? @relation(fields: [tempoIndicationId], references: [id])
  tempoIndicationId               String?
  metronomeMarks                  MetronomeMark[] // A movement can have many metronome marks
  commentId                       String?          @unique
  comment                         Comment?         @relation(fields: [commentId], references: [id])
  createdAt                       DateTime         @default(now())
  updatedAt                       DateTime         @updatedAt

  @@unique([movementId, rank])
}

model TempoIndication {
  id        String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  text      String    @unique
  sections  Section[] // A tempo indication can be used by many sections
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model MetronomeMark {
  id             String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  source         Source     @relation(fields: [sourceId], references: [id])
  sourceId       String
  beatUnit       NOTE_VALUE
  bpm            Int
  notesPerSecond Json? // Will not be used after data seeding
  notesPerBar    Json? // Will not be used after data seeding
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  section        Section    @relation(fields: [sectionId], references: [id])
  sectionId      String
  commentId      String?    @unique
  comment        Comment?   @relation(fields: [commentId], references: [id])
}

model Source {
  id             String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title          String? // ?? Is it usefull ?
  pieceVersions  PieceVersion[] // A source is linked one or more pieceVersions
  type           SOURCE_TYPE
  link           String?
  year           Int
  references     Json? // Can be plateNumber, ISBN, ISMN, etc.
  contributions  Contribution[] // A source can have many Contributions
  metronomeMarks MetronomeMark[] // A source can have many metronome marks
  creator        User?           @relation(fields: [creatorId], references: [id])
  creatorId      String?
  commentId      String?         @unique
  comment        Comment?        @relation(fields: [commentId], references: [id])
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

model Contribution {
  id             String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  source         Source            @relation(fields: [sourceId], references: [id])
  sourceId       String
  person         Person?           @relation(fields: [personId], references: [id])
  personId       String?
  organization   Organization?     @relation(fields: [organizationId], references: [id])
  organizationId String?
  role           CONTRIBUTION_ROLE
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  // Need to add a constraint to ensure that one and only one of personId or organizationId is set
  // constraint person_org_xor check ((personId IS NOT NULL AND organizationId IS NULL) OR (organizationId IS NOT NULL AND personId IS NULL))
}

model Organization {
  id            String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String         @unique
  contributions Contribution[] // An organization can have many contributions
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model Person {
  id            String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  firstName     String
  lastName      String
  birthYear     Int
  deathYear     Int?
  compositions  Piece[] // A person can have compose many pieces
  contributions Contribution[] // A person can have many contributions
  creator       User?          @relation(fields: [creatorId], references: [id])
  creatorId     String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  @@unique([firstName, lastName])
}

model Comment {
  id            String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  text          String
  creator       User?          @relation(fields: [creatorId], references: [id])
  creatorId     String?
  source        Source?
  section       Section?
  metronomeMark MetronomeMark?

  // add a constraint to ensure that one and only one of sourceId, sectionId or metronomeMarkId is set
  // constraint source_section_metronomeMark_xor check ((sourceId IS NOT NULL AND sectionId IS NULL AND metronomeMarkId IS NULL) OR (sectionId IS NOT NULL AND sourceId IS NULL AND metronomeMarkId IS NULL) OR (metronomeMarkId IS NOT NULL AND sourceId IS NULL AND sectionId IS NULL))
}

// Next-auth related models

model Account {
  id                String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  comments      Comment[] // A user can have created many comments
  sources       Source[] // A user can have created many sources
  pieces        Piece[] // A user can have created many pieces
  persons       Person[] // A user can have created many persons
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Enums

enum NOTE_VALUE {
  WHOLE
  HALF
  DOTTED_HALF
  QUARTER
  DOTTED_QUARTER
  EIGHTH
  DOTTED_EIGHTH
  SIXTEENTH
  DOTTED_SIXTEENTH
  THIRTYSECOND
  DOTTED_THIRTYSECOND
  SIXTYFOURTH
  DOTTED_SIXTYFOURTH
  HUNDREDTWENTYEIGHTH
  DOTTED_HUNDREDTWENTYEIGHTH
  TRIPLET_EIGHTH
  TRIPLET_SIXTEENTH
  QUADRUPLET_EIGHTH
  QUINTUPLET_SIXTEENTH
  QUINTUPLET_THIRTYSECOND
  SEXTUPLET_SIXTEENTH
  SEXTUPLET_THIRTYSECOND
  SEPTUPLET_SIXTEENTH
  SEPTUPLET_HUNDREDTWENTYEIGHTH
}

enum KEY {
  A_FLAT_MAJOR
  A_FLAT_MINOR
  A_MAJOR
  A_MINOR
  A_SHARP_MAJOR
  A_SHARP_MINOR
  B_FLAT_MAJOR
  B_FLAT_MINOR
  B_MAJOR
  B_MINOR
  C_FLAT_MAJOR
  C_FLAT_MINOR
  C_MAJOR
  C_MINOR
  C_SHARP_MAJOR
  C_SHARP_MINOR
  D_FLAT_MAJOR
  D_FLAT_MINOR
  D_MAJOR
  D_MINOR
  D_SHARP_MAJOR
  D_SHARP_MINOR
  E_FLAT_MAJOR
  E_FLAT_MINOR
  E_MAJOR
  E_MINOR
  F_FLAT_MAJOR
  F_FLAT_MINOR
  F_MAJOR
  F_MINOR
  F_SHARP_MAJOR
  F_SHARP_MINOR
  G_FLAT_MAJOR
  G_FLAT_MINOR
  G_MAJOR
  G_MINOR
  G_SHARP_MAJOR
  G_SHARP_MINOR
}

enum SOURCE_TYPE {
  ORIGINAL_SCORE
  LETTER
  EDITION
}

enum CONTRIBUTION_ROLE {
  COMPOSER
  EDITOR
  TRANSLATOR
  TRANSCRIBER
  ARRANGER
  PUBLISHER
  OTHER
}
